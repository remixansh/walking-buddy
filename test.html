<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rewritten Liquid Toggle</title>

    <style>
        /* Import normalize.css for browser consistency */
        @import url('https://unpkg.com/normalize.css') layer(normalize);

        /* Define CSS layers for controlling the stylesheet cascade */
        @layer normalize, base, toggle, transitions;

        @layer transitions {
          :root {
            /* Base transition speed */
            --transition: 0.2s;
            --ease: ease-out;
          }
          [data-pressed=true] .liquid__track {
            min-height: 30px;
          }
          /* This :has selector applies the bounce animation when bounce is enabled */
          [data-bounce='true']:has(:is(button:active, [data-pressed="true"])) {
            --transition: 0.6s;
            /* This is a custom physics-based bounce easing function */
            --ease: linear(
              0 0%,
              0.6091 3.69%,
              1.0259 7.24%,
              1.1733 9.05%,
              1.283 10.92%,
              1.3562 12.87%,
              1.3948 14.95%,
              1.4014 16.03%,
              1.3999 17.16%,
              1.3731 19.64%,
              1.3202 22.27%,
              1.1394 29.39%,
              1.0582 33.17%,
              0.9943 37.45%,
              0.9734 39.64%,
              0.9593 41.92%,
              0.9505 45.08%,
              0.9517 48.7%,
              0.9924 63.02%,
              1.0046 71.2%,
              1.0061 78.24%,
              1 100%
            );
          }
          
          /* Animates the mask position based on the --complete variable */
          .indicator--masked .mask {
            translate: calc(
                (var(--complete) / 100) * (100cqi - 60cqi - (0 * var(--border)))
              ) -50%;
            transition-property: height, width, margin, scale;
            transition-duration: var(--transition);
            transition-timing-function: var(--ease);
            will-change: height, width, margin;
          }
          .wrapper {
            clip-path: inset(0 0 0 0 round 100px);
            filter: blur(6px); /* This blur is crucial for the "goo" effect */
            transition: filter var(--transition) var(--ease);
          }
          [aria-pressed='true']:not([data-active='true']) .liquid__track {
            left: calc(var(--border) * 6);
          }
          
          /* Animates the track position based on the --complete variable */
          .liquid__track {
            left: 0;
            transition-property: height, width, filter, left;
            transition-duration: var(--transition);
            transition-timing-function: var(--ease);
            translate: calc(
                (var(--complete) / 100) * (100cqi - 100% - (6 * var(--border)))
              ) -50%;
          }
          
          /* Animates the handle position based on the --complete variable */
          .indicator__liquid {
            translate: calc(
                (var(--complete) / 100) * (100cqi - 100% - (2 * var(--border)))
              ) -50%;
            transition-property: scale;
            transition-duration: var(--transition);
            transition-timing-function: var(--ease);
          }
          .indicator__liquid :is(.cover, .shadow) {
            transition: opacity var(--transition) var(--ease);
          }

          /* "Squish" effect when button is pressed/dragged */
          [data-active='true'] .indicator--masked .mask,
          .liquid-toggle:active .indicator--masked .mask {
            height: calc((100% - (2 * var(--border))) * (1.65 - (var(--delta, 0) * 0.025)));
            width: calc((60% - (2 * var(--border))) * (1.65 + (var(--delta, 0) * 0.025)));
            margin-left: calc((60% - (2 * var(--border))) * ((.65 + (var(--delta, 0) * 0.025)) * -0.5));
          }
          [data-active='true'] .indicator__liquid,
          .liquid-toggle:active .indicator__liquid {
            scale: calc(1.65 + (var(--delta, 0) * 0.025)) calc(1.65 - (var(--delta, 0) * 0.025));
          }

          /* Remove the blur when active to make the "squished" shape sharp */
          [data-active='true'] .wrapper,
          .liquid-toggle:active .wrapper {
            filter: blur(0px);
          }

          [data-active='true'] .indicator__liquid .shadow,
          .liquid-toggle:active .indicator__liquid .shadow {
            opacity: 1;
          }

          [data-active='true'] .indicator__liquid .cover,
          .liquid-toggle:active .indicator__liquid .cover {
            opacity: 0;
          }

          [data-active='true'] .indicator__liquid .liquid__track,
          .liquid-toggle:active .indicator__liquid .liquid__track {
            left: calc(var(--border) * 3);
            height: calc((var(--height) * 1px) - (6 * var(--border)));
          }
        }

        @layer toggle {
          .liquid-toggle {
            /* CSS Variables for button state and size */
            --checked: hsl(
              var(--hue, 144),
              calc((8 + (var(--complete) / 100 * (92))) * 1%),
              calc((81 - (var(--complete) / 100 * (81 - 43))) * 1%)
            );
            --border: 5px;
            --width: 140;
            --height: 60;
            
            /* Set initial state */
            --complete: 0;
            --hue: 144;

            height: calc(var(--height) * 1px);
            width: calc(var(--width) * 1px);
            border-radius: 100px;
            border: 0;
            padding: 0;
            cursor: pointer;
            position: relative;
            overflow: visible;
            container-type: inline-size;
            background: #0000;
            transition: outline var(--transition) var(--ease);
            outline-offset: 2px;
          }

          .liquid-toggle:focus-visible {
            outline: 4px solid color-mix(in oklch, var(--checked), #0000);
          }

          .liquid-toggle:active {
            outline: none;
          }
          .liquid-toggle[data-active='true']:focus-visible {
            outline: 4px solid #0000;
          }

          .indicator {
            border-radius: 100px;
            pointer-events: none;
            height: 100%;
            width: 100%;
            background: var(--checked);
            position: absolute;
            top: 50%;
            scale: 1;
            left: 50%;
            translate: -50% -50%;
          }

          /* This element creates the "cut-out" effect */
          .knockout {
            height: calc(var(--height) * 1px);
            width: calc(var(--width) * 1px);
            border-radius: 100px;
            filter: url(#remove-black); /* Applies SVG filter */
            position: absolute;
            inset: 0;
            will-change: filter, scale;
            transform: translate3d(0, 0, 0);
          }
          .indicator--masked {
            background: var(--checked);
            z-index: 12;
            height: 100%;
            width: 100%;
            translate: -50% -50%;
            container-type: inline-size;

            /* The mask is the black shape that gets "cut out" */
            .mask {
              position: absolute;
              height: calc(100% - (2 * var(--border)));
              width: calc(60% - (2 * var(--border)));
              top: 50%;
              background: #000;
              left: var(--border);
              border-radius: 100px;
            }
          }

          .wrapper {
            position: absolute;
            inset: 0;
            border-radius: 100px;
          }

          /* This is the container for the "goo" effect */
          .liquids {
            position: absolute;
            inset: 0;
            transform: translate3d(0, 0, 0);
            border-radius: 100px;
            overflow: hidden;
            filter: url(#goo); /* Applies the "goo" SVG filter */

            .liquid__shadow {
              position: absolute;
              inset: 0;
              box-shadow: inset 0px 0px 3px 4px var(--checked),
                inset calc(((var(--complete) / 100) * 8px) + -4px) 0px 3px 4px
                  var(--checked);
              border-radius: 100px;
            }

            .liquid__track {
              content: '';
              height: calc((var(--height) * 1px) - (0 * var(--border)));
              width: calc((var(--width) * 1px) - (0 * var(--border)));
              background: var(--checked);
              border-radius: 100px;
              position: absolute;
              top: 50%;
            }
          }

          /* This is the handle */
          .indicator__liquid {
            position: absolute;
            height: calc(100% - (2 * var(--border)));
            width: calc(60% - (2 * var(--border)));
            container-type: inline-size;
            top: 50%;
            background: #0000;
            left: var(--border);
            border-radius: 100px;

            .shadow {
              opacity: 0;
              content: '';
              position: absolute;
              inset: 0;
              border-radius: 100px;
              box-shadow: 1px -1px 2px hsl(0 0% 100% / 0.5) inset,
                0px -1px 2px hsl(0 0% 100% / 0.5) inset,
                -1px -1px 2px hsl(0 0% 100% / 0.5) inset,
                1px 1px 2px hsl(0 0% 30% / 0.5) inset,
                -8px 4px 10px -6px hsl(0 0% 30% / 0.25) inset,
                -1px 1px 6px hsl(0 0% 30% / 0.25) inset,
                -1px -1px 8px hsl(0 0% 60% / 0.15), 1px 1px 2px hsl(0 0% 30% / 0.15),
                2px 2px 6px hsl(0 0% 30% / 0.15),
                -2px -1px 2px hsl(0 0% 100% / 0.25) inset,
                3px 6px 16px -6px hsl(0 0% 30% / 0.5);
              z-index: 20;
            }

            .cover {
              content: '';
              position: absolute;
              inset: 0;
              background: white;
              border-radius: 100px;
            }
          }
        }

        @layer base {
          *,
          *:after,
          *:before {
            box-sizing: border-box;
          }

          html {
            color-scheme: light; /* Hard-coded to light theme */
          }

          body {
            background: #fff;
            display: grid;
            place-items: center;
            min-height: 100vh;
            font-family: system-ui, sans-serif;
          }

          /* Utilities */
          .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
          }
        }
    </style>
</head>
<body>

    <main>
      <button aria-label="toggle" aria-pressed="false" class="liquid-toggle">
        <div class="knockout">
          <div class="indicator indicator--masked">
            <div class="mask"></div>
          </div>
        </div>
        <div class="indicator__liquid">
          <div class="shadow"></div>
          <div class="wrapper">
            <div class="liquids">
              <div class="liquid__shadow"></div>
              <div class="liquid__track"></div>
            </div>
          </div>
          <div class="cover"></div>
        </div>
      </button>
    </main>

    <svg class="sr-only" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <filter id="goo">
          <feGaussianBlur
            id="SvgjsFeGaussianBlur1000"
            result="SvgjsFeGaussianBlur1000"
            in="SourceGraphic"
            stdDeviation="2"
          ></feGaussianBlur>
          <feColorMatrix
            id="SvgjsFeColorMatrix1001"
            result="SvgjsFeColorMatrix1001"
            in="SvgjsFeGaussianBlur1000"
            values="
                1 0 0 0 0
                0 1 0 0 0
                0 0 1 0 0
                0 0 0 16 -10
              "
            type="matrix"
          ></feColorMatrix>
          <feComposite
            id="SvgjsFeComposite1002"
            result="SvgjsFeComposite1002"
            in="SvgjsFeColorMatrix1001"
            operator="atop"
          ></feComposite>
        </filter>
        
        <filter id="knockout" colorInterpolationFilters="sRGB">
          <feColorMatrix
            result="knocked"
            type="matrix"
            values="1 0 0 0 0
                    0 1 0 0 0
                    0 0 1 0 0
                    -1 -1 -1 1 0"
          />
          <feComponentTransfer>
            <feFuncR type="linear" slope="3" intercept="-1" />
            <feFuncG type="linear" slope="3" intercept="-1" />
            <feFuncB type="linear" slope="3" intercept="-1" />
          </feComponentTransfer>
          <feComponentTransfer>
            <feFuncR type="table" tableValues="0 0 0 0 0 1 1 1 1 1" />
            <feFuncG type="table" tableValues="0 0 0 0 0 1 1 1 1 1" />
            <feFuncB type="table" tableValues="0 0 0 0 0 1 1 1 1 1" />
          </feComponentTransfer>
        </filter>
        
        <filter id="remove-black" color-interpolation-filters="sRGB">
          <feColorMatrix
            type="matrix"
            values="1 0 0 0 0
                          0 1 0 0 0
                          0 0 1 0 0
                          -255 -255 -255 0 1"
            result="black-pixels"
          />
          <feMorphology
            in="black-pixels"
            operator="dilate"
            radius="0.5"
            result="smoothed"
          />
          <feComposite in="SourceGraphic" in2="smoothed" operator="out" />
        </filter>
      </defs>
    </svg>

    <script type="module">
        // Import GSAP and the Draggable plugin
        import gsap from 'https://cdn.skypack.dev/gsap@3.13.0'
        import Draggable from 'https://cdn.skypack.dev/gsap@3.13.0/Draggable'

        // Register the Draggable plugin with GSAP
        gsap.registerPlugin(Draggable)

        const toggle = document.querySelector('.liquid-toggle')
        
        // Hard-code the bounce feature to 'true'
        const bounce = true; 
        const bubble = true;
        document.documentElement.dataset.bounce = bounce

        /**
         * Handles the "click" animation timeline
         */
        const toggleState = async () => {
          toggle.dataset.pressed = true
          if (bubble) toggle.dataset.active = true
          
          await Promise.allSettled(
            !bounce
              ? toggle.getAnimations({ subtree: true }).map((a) => a.finished)
              : []
          )
          
          const pressed = toggle.matches('[aria-pressed=true]')
          
          // GSAP timeline to animate the button slide
          gsap
            .timeline({
              onComplete: () => {
                gsap.delayedCall(0.05, () => {
                  toggle.dataset.active = false
                  toggle.dataset.pressed = false
                  toggle.setAttribute(
                    'aria-pressed',
                    !toggle.matches('[aria-pressed=true]')
                  )
                })
              },
            })
            .to(toggle, {
              '--complete': pressed ? 0 : 100, // Animate from 0 to 100 or 100 to 0
              duration: 0.12,
              delay: bounce && bubble ? 0.18 : 0,
            })
        }
        
        // Create a proxy element for dragging
        const proxy = document.createElement('div')
        
        // Use GSAP Draggable to handle drag interactions
        Draggable.create(proxy, {
          allowContextMenu: true,
          handle: '.liquid-toggle',
          onDragStart: function () {
            // Calculate drag bounds
            const toggleBounds = toggle.getBoundingClientRect()
            const pressed = toggle.matches('[aria-pressed=true]')
            const bounds = pressed
              ? toggleBounds.left - this.pointerX
              : toggleBounds.left + toggleBounds.width - this.pointerX
            this.dragBounds = bounds
            toggle.dataset.active = true // Activate "squish" effect
          },
          onDrag: function () {
            const pressed = toggle.matches('[aria-pressed=true]')
            const dragged = this.x - this.startX
            
            // Map drag distance to the --complete variable (0-100)
            const complete = gsap.utils.clamp(
              0,
              100,
              pressed
                ? gsap.utils.mapRange(this.dragBounds, 0, 0, 100, dragged)
                : gsap.utils.mapRange(0, this.dragBounds, 0, 100, dragged)
            )
            this.complete = complete
            
            // Update --complete and --delta (for squish intensity)
            gsap.set(toggle, { '--complete': complete, '--delta': Math.min(Math.abs(this.deltaX), 12) })
          },
          onDragEnd: function () {
            // Snap the toggle to 0 or 100
            gsap.fromTo(
              toggle,
              {
                '--complete': this.complete,
              },
              {
                '--complete': this.complete >= 50 ? 100 : 0,
                duration: 0.15,
                onComplete: () => {
                  gsap.delayedCall(0.05, () => {
                    toggle.dataset.active = false
                    toggle.setAttribute('aria-pressed', this.complete >= 50)
                  })
                },
              }
            )
          },
          onPress: function () {
            this.__pressTime = Date.now()
            if ('ontouchstart' in window && navigator.maxTouchPoints > 0)
              toggle.dataset.active = true
          },
          onRelease: function () {
            this.__releaseTime = Date.now()
            gsap.set(toggle, { '--delta': 0 })
            
            if (
              'ontouchstart' in window &&
              navigator.maxTouchPoints > 0 &&
              ((this.startX !== undefined &&
                this.endX !== undefined &&
                Math.abs(this.endX - this.startX) < 4) ||
                this.endX === undefined)
            )
              toggle.dataset.active = false
            
            // If the press/release was fast (< 150ms), treat it as a "click"
            if (this.__releaseTime - this.__pressTime <= 150) {
              toggleState()
            }
          },
        })

        // Add keyboard support for accessibility
        toggle.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            toggleState()
          }
          if (e.key === ' ') {
            e.preventDefault() // Prevent page scroll
          }
        })

        toggle.addEventListener('keyup', (e) => {
          if (e.key === ' ') {
            toggleState()
          }
        })
    </script>
</body>
</html>